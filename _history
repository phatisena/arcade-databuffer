{"entries":[{"timestamp":1745030058830,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":4201,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":214,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1745030649770,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4192,"length1":903,"diffs":[[1,""]]}]}]},{"timestamp":1745031249536,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5023,"length1":123,"diffs":[[1,"                numv = img.getPixel(xi, yi)\n                }\n"]]},{"start1":5095,"length1":75,"diffs":[[1,""]]},{"start1":5102,"length1":726,"diffs":[[1,""]]}]}]},{"timestamp":1745031849491,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4931,"length1":60,"diffs":[[1,"            if (img.getPixel(xi, yi) == numv) {\n                numc++\n            } else {\n                numarrv.push(numc), numarrv.push(numv)\n                numv = img.getPixel(xi, yi), numc = 0\n            }\n"]]},{"start1":5624,"length1":14,"diffs":[[1,"        }\n"]]},{"start1":5699,"length1":34,"diffs":[[1,"        while (bytelen > 0) {\n            i++\n"]]},{"start1":5927,"length1":332,"diffs":[[1,""]]},{"start1":5937,"length1":0,"diffs":[[1,"        h = byteval,\n"]]}]}]},{"timestamp":1745032438742,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4860,"length1":73,"diffs":[[1,"            const xi = (i % img.width), yi = Math.floor(i / img.width)\n"]]},{"start1":5001,"length1":0,"diffs":[[1,"        numarrv.push(0)\n"]]},{"start1":5216,"length1":59,"diffs":[[1,"        let w = 0, h = 0, img: Image\n"]]},{"start1":5381,"length1":83,"diffs":[[1,"            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n            bytelen--\n        } i++\n"]]},{"start1":5676,"length1":185,"diffs":[[1,"            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n            bytelen--\n        } i++\n        h = byteval, img = image.create(w, h)\n        let ii = 0\n"]]},{"start1":5877,"length1":129,"diffs":[[1,"            bytelen = bufv[i], i++, byteval = bufv[i], i++\n            while (bytelen > 0) {\n                const xi = (ii % w), yi = Math.floor(ii / w)\n                img.setPixel(xi, yi, byteval)\n            ii++ }\n        }\n"]]}]}]},{"timestamp":1745033038132,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1736,"length1":389,"diffs":[[1,"            if (bytelen > 0) {\n                if (bytesum > 0) byteval += bufv[i] * bytesum\n                else byteval += bufv[i]\n                bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n                bytelen--\n            } else if (bytelen <= 0 && bytelen == bufv[i]) {\n                strtxt += String.fromCharCode(byteval)\n                strarr.push(strtxt)\n                strtxt = \"\"\n            } else {\n                bytelen = bufv[i]\n                strtxt += String.fromCharCode(byteval)\n                byteval = 0, bytesum = 0\n            }\n"]]},{"start1":2712,"length1":268,"diffs":[[1,"        for (let i = 0; i < txtv.length; i++) {\n            let numv = txtv.charCodeAt(i)\n            let bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n            numarrv.push(bytelen)\n            for (let j = 0; j < bytelen; j++) {\n                numarrv.push(numv % bytemax)\n                numv = Math.floor(numv / bytemax)\n            }\n        }\n        numarrv.push(0)\n"]]},{"start1":3520,"length1":396,"diffs":[[1,"        let strtxt: string = \"\"\n        let bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) {\n            if (bytelen > 0) {\n                if (bytesum > 0) byteval += bufv[i] * bytesum\n                else byteval += bufv[i]\n                bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n                bytelen--\n            } else {\n                bytelen = bufv[i]\n                strtxt += String.fromCharCode(byteval)\n                byteval = 0, bytesum = 0\n            }\n        }\n"]]},{"start1":4157,"length1":505,"diffs":[[1,"        let numarrv: number[] = []\n        let bytelen: number,bytemax: number, numv: number, numc: number\n        numv = img.width, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n        numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) {\n            numarrv.push(numv % bytemax)\n            numv = Math.floor(numv / bytemax)\n        }\n        numv = img.height, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n        numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) {\n            numarrv.push(numv % bytemax)\n            numv = Math.floor(numv / bytemax)\n        }\n"]]},{"start1":4801,"length1":182,"diffs":[[1,"        for (let i = 1;i < (img.width * img.height);i++) {\n            const xi = Math.floor(i / img.height), yi = (i % img.height)\n            numarrv.push(numv), numv = img.getPixel(xi, yi)\n        }\n"]]},{"start1":5109,"length1":247,"diffs":[[1,"        let i = 0, bytemax = 8 ** 2 * 4, bytelen = bufv[i], byteval = 0, bytesum = 0\n        let w = 0, h = 0, img: Image, imgRowBuffer: Buffer\n        while (bytelen > 0) { i++\n            if (bytesum > 0) byteval += bufv[i] * bytesum\n            else byteval += bufv[i]\n"]]},{"start1":5464,"length1":175,"diffs":[[1,"        w = byteval, bytelen = bufv[i], byteval = 0, bytesum = 0\n        while (bytelen > 0) { i++\n            if (bytesum > 0) byteval += bufv[i] * bytesum\n            else byteval += bufv[i]\n"]]},{"start1":5740,"length1":87,"diffs":[[1,"        h = byteval, img = image.create(w, h), imgRowBuffer = pins.createBuffer(h)\n        let i0 = 0\n"]]}]}]},{"timestamp":1745033636323,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":222,"length1":0,"diffs":[[1,"     * convert array of string to buffer string\n     * @param array of string to encode\n     * @returns after convert array of string to buffer string\n     */\n    //% blockid=databuff_encode_string_array\n    //% block=\"get string array of $bufv convert to buffer\"\n    //% group=\"string\"\n    //% weight=50\n    export function encodeTextArr(txtarr: string[]) {\n        let numarrv: number[] = []\n        for (let txtv of txtarr) {\n            for (let i = 0; i < txtv.length; i++) {\n                let numv = txtv.charCodeAt(i)\n                let bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n                numarrv.push(bytelen)\n                for (let j = 0; j < bytelen; j++) {\n                    numarrv.push(numv % bytemax)\n                    numv = Math.floor(numv / bytemax)\n                }\n            }\n            numarrv.push(0)\n        }\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    /**\n     * convert buffer string to array of string\n     * @param buffer string to decode\n     * @returns after convert buffer to array of string\n     */\n    //% blockid=databuff_decode_string_array\n    //% block=\"get buffer of $bufv convert to string array\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=25\n    export function decodeTextArr(bufv: Buffer) {\n        let strarr: string[] = []\n        let strtxt: string = \"\"\n        let bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) {\n            if (bytelen > 0) { if (bytesum > 0) { byteval += bufv[i] * bytesum } else { byteval += bufv[i] } bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } else if (bytelen <= 0 && bytelen == bufv[i]) { strtxt += String.fromCharCode(byteval), strarr.push(strtxt), strtxt = \"\" } else { bytelen = bufv[i], strtxt += String.fromCharCode(byteval), byteval = 0, bytesum = 0\n        }\n        return strarr\n    }\n\n    /**\n"]]},{"start1":3648,"length1":1742,"diffs":[[1,""]]},{"start1":4243,"length1":275,"diffs":[[1,"        for (let i = 1;i < (img.width * img.height);i++) { const xi = Math.floor(i / img.height), yi = (i % img.height)\n            numarrv.push(numv), numv = img.getPixel(xi, yi) }\n"]]},{"start1":4672,"length1":642,"diffs":[[1,"        while (bytelen > 0) { i++; if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } i++\n            w = byteval, bytelen = bufv[i], byteval = 0, bytesum = 0\n        while (bytelen > 0) { i++; if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } i++\n            h = byteval, img = image.create(w, h), imgRowBuffer = pins.createBuffer(h)\n        while (i < bufv.length) {\n            for (let i1 = 0;i1 < h;i1++, i++) imgRowBuffer[i1] = bufv[i]\n            img.setRows(i0, imgRowBuffer)\n        i0++}\n"]]},{"start1":5375,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1745034304790,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5047,"length1":135,"diffs":[[1,"        while (i < bufv.length) { for (let i1 = 0;i1 < h;i1++, i++) imgRowBuffer[i1] = bufv[i]; img.setRows(i0, imgRowBuffer), i0++}\n"]]}]}]},{"timestamp":1745034335554,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2,"length1":54,"diffs":[[1,"//% color=\"#7C9BDE\" icon=\"\\uf187\"\n"]]},{"start1":3440,"length1":345,"diffs":[[1,""]]},{"start1":4035,"length1":255,"diffs":[[1,"        for (let i = 1;i < (img.width * img.height);i++) { const xi = Math.floor(i / img.height), yi = (i % img.height); numarrv.push(numv); if (img.getPixel(xi, yi) == numv) { numc++ } else { numarrv.push(numc), numarrv.push(numv), numv = img.getPixel(xi, yi), numc = 1 } }\n"]]},{"start1":4793,"length1":510,"diffs":[[1,"        while (bytelen > 0) { i++; if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]; bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } i++, h = byteval, img = image.create(w, h), imgRowBuffer = pins.createBuffer(h)\n        while (i < bufv.length) { for (let i1 = 0;i1 < h;i1++, i++) ifimgRowBuffer[i1] = bufv[i]; img.setRows(i0, imgRowBuffer), i0++}\n"]]},{"start1":5210,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1745034932555,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":56,"length1":23,"diffs":[[1,"namespace DataBuff {\n"]]},{"start1":1100,"length1":61,"diffs":[[1,"    //% block=\"get buffer of $bufv convert to string\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n"]]},{"start1":1930,"length1":62,"diffs":[[1,"    //% block=\"get string array of $bufv convert to buffer\"\n"]]},{"start1":2682,"length1":68,"diffs":[[1,"    //% block=\"get buffer of $bufv convert to string array\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n"]]},{"start1":3635,"length1":113,"diffs":[[1,"    //% block=\"get image of $img=screen_image_picker convert to string array\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=25\n"]]},{"start1":4713,"length1":283,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":92,"diffs":[[1,"    \"name\": \"arcade-databuff\",\n    \"description\": \"\",\n"]]},{"start1":214,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1745030058829,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-databuff\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1745031864623,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n\n//% color=\"#7C9BDE\" icon=\"\\uf187\"\nnamespace DataBuff {\n\n    function bitcalc(nv: number, bl: number) {\n        const bsum = bl ** 2 * 4, isum = Math.ceil(Math.log(nv) / Math.log(bsum))\n        return isum\n    }\n\n    /**\n     * convert array of string to buffer string\n     * @param array of string to encode\n     * @returns after convert array of string to buffer string\n     */\n    //% blockid=databuff_encode_string_array\n    //% block=\"get string array of $bufv convert to buffer\"\n    //% group=\"string\"\n    //% weight=50\n    export function encodeTextArr(txtarr: string[]) {\n        let numarrv: number[] = []\n        for (let txtv of txtarr) {\n            for (let i = 0; i < txtv.length; i++) {\n                let numv = txtv.charCodeAt(i)\n                let bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n                numarrv.push(bytelen)\n                for (let j = 0; j < bytelen; j++) {\n                    numarrv.push(numv % bytemax)\n                    numv = Math.floor(numv / bytemax)\n                }\n            }\n            numarrv.push(0)\n        }\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    /**\n     * convert buffer string to array of string\n     * @param buffer string to decode\n     * @returns after convert buffer to array of string\n     */\n    //% blockid=databuff_decode_string_array\n    //% block=\"get buffer of $bufv convert to string array\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=25\n    export function decodeTextArr(bufv: Buffer) {\n        let strarr: string[] = []\n        let strtxt: string = \"\"\n        let bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) {\n            if (bytelen > 0) {\n                if (bytesum > 0) byteval += bufv[i] * bytesum\n                else byteval += bufv[i]\n                bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n                bytelen--\n            } else if (bytelen <= 0 && bytelen == bufv[i]) {\n                strtxt += String.fromCharCode(byteval)\n                strarr.push(strtxt)\n                strtxt = \"\"\n            } else {\n                bytelen = bufv[i]\n                strtxt += String.fromCharCode(byteval)\n                byteval = 0, bytesum = 0\n            }\n        }\n        return strarr\n    }\n\n    /**\n     * convert string to buffer string\n     * @param string input to encode\n     * @returns after convert string to buffer string\n     */\n    //% blockid=databuff_encode_string\n    //% block=\"get string of $txtv convert to buffer\"\n    //% group=\"string\"\n    //% weight=100\n    export function encodeText(txtv: string) {\n        let numarrv: number[] = []\n        for (let i = 0; i < txtv.length; i++) {\n            let numv = txtv.charCodeAt(i)\n            let bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n            numarrv.push(bytelen)\n            for (let j = 0; j < bytelen; j++) {\n                numarrv.push(numv % bytemax)\n                numv = Math.floor(numv / bytemax)\n            }\n        }\n        numarrv.push(0)\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    /**\n     * convert buffer string to string\n     * @param buffer string to decode\n     * @returns after convert buffer to text\n     */\n    //% blockid=databuff_decode_string\n    //% block=\"get buffer of $bufv convert to string\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=75\n    export function decodeText(bufv: Buffer) {\n        let strtxt: string = \"\"\n        let bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) {\n            if (bytelen > 0) {\n                if (bytesum > 0) byteval += bufv[i] * bytesum\n                else byteval += bufv[i]\n                bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n                bytelen--\n            } else {\n                bytelen = bufv[i]\n                strtxt += String.fromCharCode(byteval)\n                byteval = 0, bytesum = 0\n            }\n        }\n        return strtxt\n    }\n\n    export function encodeImage(img: Image) {\n        let numarrv: number[] = []\n        let bytelen: number,bytemax: number, numv: number, numc: number\n        numv = img.width, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n        numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) {\n            numarrv.push(numv % bytemax)\n            numv = Math.floor(numv / bytemax)\n        }\n        numv = img.height, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n        numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) {\n            numarrv.push(numv % bytemax)\n            numv = Math.floor(numv / bytemax)\n        }\n        numv = img.getPixel(0, 0), numc = 1\n        for (let i = 1;i < (img.width * img.height);i++) {\n            const xi = (i % img.width), yi = Math.floor(i / img.width)\n            if (img.getPixel(xi, yi) == numv) {\n                numc++\n            } else {\n                numarrv.push(numc), numarrv.push(numv)\n                numv = img.getPixel(xi, yi), numc = 0\n            }\n        }\n        numarrv.push(0)\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    export function decodeImage(bufv: Buffer) {\n        let i = 0, bytemax = 8 ** 2 * 4, bytelen = bufv[i], byteval = 0, bytesum = 0\n        let w = 0, h = 0, img: Image\n        while (bytelen > 0) { i++\n            if (bytesum > 0) byteval += bufv[i] * bytesum\n            else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n            bytelen--\n        }\n        w = byteval, bytelen = bufv[i], byteval = 0, bytesum = 0\n        while (bytelen > 0) {\n            i++\n            if (bytesum > 0) byteval += bufv[i] * bytesum\n            else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax\n            bytelen--\n        }\n        h = byteval, img = im\n    }\n}\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-databuff\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1745033665031,"editorVersion":"2.0.48","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n\n//% color=\"#7C9BDE\" icon=\"\\uf187\"\nnamespace DataBuff {\n\n    function bitcalc(nv: number, bl: number) {\n        const bsum = bl ** 2 * 4, isum = Math.ceil(Math.log(nv) / Math.log(bsum))\n        return isum\n    }\n\n    /**\n     * convert array of string to buffer string\n     * @param array of string to encode\n     * @returns after convert array of string to buffer string\n     */\n    //% blockid=databuff_encode_string_array\n    //% block=\"get string array of $bufv convert to buffer\"\n    //% group=\"string\"\n    //% weight=50\n    export function encodeTextArr(txtarr: string[]) {\n        let numarrv: number[] = []\n        for (let txtv of txtarr) {\n            for (let i = 0; i < txtv.length; i++) {\n                let numv = txtv.charCodeAt(i)\n                let bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4\n                numarrv.push(bytelen)\n                for (let j = 0; j < bytelen; j++) {\n                    numarrv.push(numv % bytemax)\n                    numv = Math.floor(numv / bytemax)\n                }\n            }\n            numarrv.push(0)\n        }\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    /**\n     * convert buffer string to array of string\n     * @param buffer string to decode\n     * @returns after convert buffer to array of string\n     */\n    //% blockid=databuff_decode_string_array\n    //% block=\"get buffer of $bufv convert to string array\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=25\n    export function decodeTextArr(bufv: Buffer) {\n        let strarr: string[] = []\n        let strtxt: string = \"\", bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) if (bytelen > 0) { if (bytesum > 0) { byteval += bufv[i] * bytesum } else { byteval += bufv[i] } bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } else if (bytelen <= 0 && bytelen == bufv[i]) { strtxt += String.fromCharCode(byteval), strarr.push(strtxt), strtxt = \"\" } else { bytelen = bufv[i], strtxt += String.fromCharCode(byteval), byteval = 0, bytesum = 0 }\n        return strarr\n    }\n\n    /**\n     * convert string to buffer string\n     * @param string input to encode\n     * @returns after convert string to buffer string\n     */\n    //% blockid=databuff_encode_string\n    //% block=\"get string of $txtv convert to buffer\"\n    //% group=\"string\"\n    //% weight=100\n    export function encodeText(txtv: string) {\n        let numarrv: number[] = []\n        for (let i = 0; i < txtv.length; i++) { let numv = txtv.charCodeAt(i), bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4; numarrv.push(bytelen); for (let j = 0; j < bytelen; j++) numarrv.push(numv % bytemax), numv = Math.floor(numv / bytemax) } numarrv.push(0)\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    /**\n     * convert buffer string to string\n     * @param buffer string to decode\n     * @returns after convert buffer to text\n     */\n    //% blockid=databuff_decode_string\n    //% block=\"get buffer of $bufv convert to string\"\n    //% bufv.shadow=variables_get bufv.defl=Buffer\n    //% group=\"string\"\n    //% weight=75\n    export function decodeText(bufv: Buffer) {\n        let strtxt: string = \"\", bytelen = bufv[0], bytesum = 0, byteval = 0, bytemax = 8 ** 2 * 4\n        for (let i = 1; i < bufv.length; i++) if (bytelen > 0) { if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]; bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } else { bytelen = bufv[i], strtxt += String.fromCharCode(byteval), byteval = 0, bytesum = 0 }\n        return strtxt\n    }\n\n    export function encodeImage(img: Image) {\n        let numarrv: number[] = [], bytelen: number,bytemax: number, numv: number, numc: number\n        numv = img.width, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4, numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) numarrv.push(numv % bytemax), numv = Math.floor(numv / bytemax)\n        numv = img.height, bytelen = bitcalc(numv, 8), bytemax = 8 ** 2 * 4, numarrv.push(bytelen)\n        for (let j = 0; j < bytelen; j++) numarrv.push(numv % bytemax), numv = Math.floor(numv / bytemax)\n        numv = img.getPixel(0, 0), numc = 1\n        for (let i = 1;i < (img.width * img.height);i++) { const xi = Math.floor(i / img.height), yi = (i % img.height)\n            numarrv.push(numv), numv = img.getPixel(xi, yi) }\n        return pins.createBufferFromArray(numarrv)\n    }\n\n    export function decodeImage(bufv: Buffer) {\n        let i = 0, i0 = 0, bytemax = 8 ** 2 * 4, bytelen = bufv[i], byteval = 0, bytesum = 0, w = 0, h = 0, img: Image, imgRowBuffer: Buffer\n        while (bytelen > 0) { i++; if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } i++\n            w = byteval, bytelen = bufv[i], byteval = 0, bytesum = 0\n        while (bytelen > 0) { i++; if (bytesum > 0) byteval += bufv[i] * bytesum; else byteval += bufv[i]\n            bytesum = (bytesum > 0) ? bytesum * bytemax : bytemax, bytelen-- } i++\n            h = byteval, img = image.create(w, h), imgRowBuffer = pins.createBuffer(h)\n        while (i < bufv.length) {\n            for (let i1 = 0;i1 < h;i1++, i++) imgRowBuffer[i1] = bufv[i]\n            img.setRows(i0, imgRowBuffer)\n        i0++}\n    }\n}\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-databuff\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1745035223973}